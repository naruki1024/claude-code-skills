抽選キャンペーンページ
キーワードやクリエイターで検索


3
メニュー
 投稿

見出し画像
Agent Skillsはスラッシュコマンドじゃないって。

46
そら ☁️ Dify 自動化オタク📱
そら ☁️ Dify 自動化オタク📱
2025年12月30日 15:55
参加中
~Task × Context Engineering で見る、Skillsの本当の価値~

第1章　「それ、スラッシュコマンドでよくない？」というモヤモヤから
Claude CodeにSkillsが来たとき、タイムラインを見ていて最初に目についたのは、技術的な盛り上がりよりも、「え、これ結局スラッシュコマンドの焼き直しじゃないの？」という空気だった。

「/review みたいなコマンドを、Markdownに書いてるだけでしょ」
「Cursor以外でも動く“スラコマ”ってこと？」

こんな反応が、XやDiscordでずっと流れていた。

正直、その感覚は分からなくもない。表面だけ並べると、確かに似ている。

あらかじめ指示を書いておく

それを呼び出して、Claudeにタスクをやらせる

スラッシュコマンドもSkillsも、この構造だけ見れば同じに見える。
違うのは UI と「/」を打つかどうかだけ、という理解になりやすい。

ただ、僕が実際にSkillsを触り込んで、何本もSkillを設計していくうちに、ここにはかなり致命的な見落としがあると感じた。

「スラッシュコマンドと同じ」に見えてしまうのは、“コンテキストをどう設計しているか”という視点がすっぽり抜けているからだ。

LLMの世界で本当に効いてくるのは、
「どんなプロンプトを書いたか」よりも、
「どんなコンテキストを、どんな構造で渡したか」だ。

Skillsは、この「コンテキスト設計」を扱うための仕組みとして作られている。
スラッシュコマンドの“高機能版”というより、

Context Engineering を最高に実現するためのフレームワーク

として見る方がしっくりくる。

画像
ここまでをまとめると…
それを実感したのがこの投稿。


Compactを一回も使わずに1時間駆動し、精度もかなり良かったです。

ここで、あえてざっくり比較しておく。

Slash Commands

Cursorの中だけで完結する

ユーザーが /command を叩いた瞬間に動く

指定したMarkdownがそのままコンテキストに「追加」される

「どのタイミングで、何をどれだけ読むか」の制御は弱い

Skills

Claude Code / Codex / Cursor 将来の実行環境にもまたがって使える前提

エージェントが「必要だ」と判断したタイミングで自動的に起動される

メタデータ → SKILL.md → agents / references…と段階的にロードされる

Task単位でコンテキストを分離し、結果だけをメインに返せる

同じ「事前定義された指示」であることは確かだけど、
扱っているレイヤーがそもそも違う。

ここで出てくるのが、LangChainが初めに提唱した Context Engineering という考え方。

ざっくり言うと、

LLMがタスクをちゃんと完走できるように、
「どの情報」「どのツール」を「どのタイミング」で渡すかを設計すること

だと思ってもらえばいい。

プロンプトを一発で書き切るのではなく、
ワークフロー全体の中で「コンテキストの出し入れ」をデザインする発想。

Skillsはまさにこの文脈に乗っている。

画像
ここまでをまとめると…
自己紹介が遅れました。

そら（福島楓人、またの名はふっくー）です。
X（旧Twitter）では「AI×自動化」について発信しながら、生成AIエンジニアとして法人向けのAIシステム開発や業務自動化をやっています。

学生・若手向けAIコミュニティ「gakuse.ai」の代表として、普段は大企業でエンジニアをしつつ、個人でAI導入支援やスクール講師、イベント企画なども並行して動かしています。

現場で毎日のようにLLMエージェントを設計していると、「モデルの賢さ」よりも「コンテキストの設計」がボトルネックになる場面がひたすら出てきます。

途中から出した情報をモデルが忘れる

逆に、要らないログまで全部抱え込んでぐちゃぐちゃになる

長時間走らせると、どこかでコンテキストが破綻して破綻する

この辺の「コンテキストの扱いの雑さ」が、エージェントの失敗のかなりの割合を占めている感覚があります。

だからこそ、僕はSkillsを「便利なショートカットの集合」としてではなく、

コンテキストをどう分割するか

どこで切り替えるか

何を外部ファイルに逃がすか

どこから先をスクリプトに渡すか

という、設計レベルの話として見ています。

このnoteでは、単に「Skills便利だよ」という話はしません。

Taskという仕組みで、コンテキストをどう分離しているのか

skills/agents/*.md が「サブエージェント定義」ではなく「Task仕様書」だと考えるべき理由

references/ ディレクトリで、知識をどう外部化しているのか

scripts/ を組み合わせた瞬間に、Skillsが「思考 × 自動化」を兼ねた装置になる流れ

このあたりを、Context Engineering という視点で整理していきます。

「スラッシュコマンドと同じでしょ？」という雑な理解のままだと、
Skillsのポテンシャルの8割くらいは取りこぼすことになります。

この記事は、
「Skillsを“ただの便利機能”から、“設計の道具”として扱いたい人」向けの解説です。

ここから、まずは基礎になる「Taskとは何か」から掘っていきます。

ここから先は有料部分です

目次
第1章　「それ、スラッシュコマンドでよくない？」というモヤモヤから
第2章　まず「Taskって何なのか」をちゃんと押さえる
Taskがやっていること
技術記事ライティングを例にすると
Taskが「コンテキスト設計」の中で持つ意味
第3章　なぜメインエージェントに「全部」入れちゃダメなのか
コンテキストが壊れる典型パターン
Skillsがやっていることは「情報の追加」ではなく「分離」
「分離されたコンテキスト」が何を守っているか
第4章　.claude/agents と skills/agents の「読み込まれ方」の違い

すべて表示
第2章　まず「Taskって何なのか」をちゃんと押さえる
Skillsを理解しようとするときに、いきなりSKILL.mdの書き方から入ると高確率でつまずきます。最初に整理すべきなのは、もっと地味で、でも根本にある「Task」という概念です。

Taskは、一言でまとめると

Claude Code がその場で立ち上げて、仕事が終わったら即解散する「一時労働者」

の単発バイトのような存在です。
「サブエージェント」なのかな？と思ったのですが、実際触ってみたら近かったです。

Anthropic公式の説明でも、

「新しい人格を永続的に増やすものではない」

「必要なときだけ起動される、一時的なClaudeのワーカー」

という位置づけになっています。

画像
Taskの概念
Taskがやっていること
普段、メインのClaude Codeに重めのタスクを投げると、履歴がどんどん溜まっていきます。

何個もファイルを開く

何度もコードを書き直す

テストを回す

ログが積み上がる

全部ひとつのコンテキストに居座り続けるので、気づいたら200kトークンがパンパン、みたいな状態になる。

Taskを使うと、この構造が変わります。

各Taskは「独立した」コンテキストウィンドウを持つ

1つのTaskにつき、およそ 200k トークン分の作業領域が与えられる

最大で 10 個程度まで並列起動できる

Taskが終わると、その中身ごと消えて、結果だけがメインに返る

メインのエージェントは、あくまで「司令塔」。
重たい作業は、別プロセスとしてTaskに丸投げしているイメージに近いです。

結果どうなるかというと、
メインエージェントのコンテキストは、最後までスカスカに保てる。

「どんなタスクを、どの順番で進めるか」

「この結果は基準を満たしているか」

みたいな“判断”に集中させて、
リサーチや書き直しで発生する膨大なログは、Task側で消費してもらう設計になっている。

画像
Taskがやっていること
技術記事ライティングを例にすると
僕が試した構成のひとつを例にします。技術記事を書くためのSkillを考えると、ディレクトリはざっくりこうなります。

.claude/skills/tech-article-writer/
  SKILL.md                    # 全体のワークフロー
  agents/
    article-research.md       # リサーチ担当Taskの仕様
    article-outline.md        # アウトライン作成担当Taskの仕様
    article-writer.md         # 執筆担当Taskの仕様
    article-reviewer.md       # レビュー担当Taskの仕様
    article-extract.md        # 抽出担当Taskの仕様
    article-image-planner.md  # 画像計画担当Taskの仕様
    article-image-curator.md  # 画像キュレーション担当Taskの仕様
    article-profile.md        # プロフィール追加担当Taskの仕様
    article-linker.md         # リンク追加担当Taskの仕様
    article-cta.md            # CTA追加担当Taskの仕様
  references/
    author-profile.md         # 著者プロフィールリファレンス
    cta-resources.md          # CTAリソースリファレンス
    image-sources.md          # 画像ソースリファレンス
    note-best-practices.md    # ノートベストプラクティス
    writing-examples.md       # 執筆例リファレンス

copy
ここでSKILL.mdは「指揮者」です。

ざっくりフローをまとめると、

ユーザーから「この記事を書いて」と依頼が来る

SKILL.mdを読んだメインエージェントが、まず「リサーチTask」を起動する

リサーチTaskは、独立したコンテキストの中で

Web検索を回しまくり

情報を整理し

要約だけをメインに返す

リサーチTaskはそこで消える

次に「執筆Task」が起動される

受け取るのは「リサーチの要約」やアウトラインなど、最小限の情報だけ

何度書き直しても、その思考ログは執筆Taskのコンテキストに閉じる

執筆が終わったら、今度は「レビューTask」が立ち上がり、ドラフトをチェックする

ポイントは、フェーズごとに「使うコンテキスト」が完全に入れ替わるところです。

リサーチ中に読んだ 100 個のページのログは、執筆フェーズには持ち込まれない。
執筆中の思考ログも、レビュー担当からすればどうでもいいので残らない。

メインエージェントには、

「リサーチの要約」

「最終ドラフト」

「レビュー結果」

のような「次の判断に必要な結果」だけが返ってくる。

人間の仕事に置き換えると、

情報収集班

ライター

校正・編集

が、それぞれ別部屋で作業して、
完成物だけ編集長の机に届くような感じです。
編集長の机がごちゃごちゃにならないように、最初から構造を決めている。

画像
僕の実例はこんな感じです。
Taskが「コンテキスト設計」の中で持つ意味
OpenAI共同創業者 Andrej Karpathyが「LLMはOSであり、コンテキストウィンドウはRAMだ」と表現していましたが、この比喩を借りるとかなり分かりやすいです。

モデル本体 = CPU

コンテキストウィンドウ = 作業用のメモリ

Task = 別プロセス

メインのプロセスだけで全部やろうとすると、
メモリが足りなくなったり、不要なデータを抱え込みすぎて遅くなったりする。

そこで、

重たい処理は別プロセス（Task）で走らせて

結果だけをメインに返す

という設計にすることで、
実質的な「使えるメモリ総量」を拡張しつつ、判断の精度も落とさない構造になる。

ここまで来ると、「スラッシュコマンドと同じじゃないの？」という話からはだいぶ遠いところにいるはずです。

スラッシュコマンドは「保存したプロンプトを一気に流し込む」仕組み。
Taskは「コンテキストを分割して、プロセスごとに使い捨てる」仕組み。

見た目は似ていても、やっていることは別物です。

画像
コンテキスト設計
次の章では、このTaskを実際に扱ううえでキーになる skills/agents/*.md の位置づけについて掘っていきます。ここを「サブエージェント定義」と誤解していると、Skillsの設計を間違えがちなので、一回きれいに言語化しておきます。

第3章　なぜメインエージェントに「全部」入れちゃダメなのか
エージェントを触っていると、だいたい最初にやりがちなのがこれです。

「とりあえず全部コンテキストに突っ込んでおけば、モデルがいい感じに処理してくれるでしょ」

残念ながら、これが一番事故るパターンです。

最近のフロンティアモデルは、よほど無茶をしなければ「頭が悪くて失敗する」ことはあまりありません。
多くのケースで本当に起きているのは、

モデルがダメなのではなく渡しているコンテキストがダメ

というパターンです。

コンテキストが壊れる典型パターン
技術記事を書くワークフローを、1つのコンテキストだけで回そうとするとどうなるか。

例えばこんな感じになりがちです。

リサーチで Web ページを 30 個読む

だいたい 5〜6 万トークンくらい飛ぶ

執筆でドラフトを何度も書き直す

ここでさらに数万トークン

レビューで修正を重ねる

コメントや差分がまた積み上がる

気づくと、10万トークンくらいは平気で消費している。

この状態で起きる問題はだいたい決まっています。

1つ目は、判断が濁ること。
人間もそうですが、机の上にいらない資料が散乱していると、
「どれを見て判断すべきか」を考えるだけでエネルギーを持っていかれます。
LLMも同じで、「関係ないもの」が増えるほど、判断がブレやすくなる。

2つ目は、コンテキスト不足による劣化。
上限に近づくと、古い情報から順に圧縮・削除されていきます。
このとき、モデル側の判断で勝手に要約されるので、本当に重要な部分が削られることも普通にある。

「ちゃんと動いていたはずのエージェントが、急におかしなことを言い始める」のは、
モデルの性能よりも、このコンテキストの崩壊が原因になっているケースが多いです。

画像
メインエージェントにコンテキストをぶち込むな！
Skillsがやっていることは「情報の追加」ではなく「分離」
ここでTaskとSkillsの話に戻ります。

さっきまでの「全部1コンテキストに詰め込む」世界線とは違って、Skills前提の設計では、
メインエージェントとTaskの関係はだいたいこんなイメージになります。

メインエージェント（オーケストレーター）

ユーザーの依頼を受け取る

どのTaskをどの順番で呼ぶかを決める

各Taskから返ってきた「要約された結果」だけを持つ

Skillsで実行されるTaskたち（リサーチ担当 / 執筆担当 など）

独立したコンテキストをそれぞれ持つ

自分の中では、Webページを読みまくっても、ドラフトを何度も破棄してもOK

仕事が終わったら、必要な結果だけを返してコンテキストごと消える

つまり、

スラッシュコマンド
→ メインのコンテキストに「プロンプトや知識を追加する」

Skills + Task
→ 「処理そのものを別コンテキストに分離して、結果だけ戻す」

という違いがある。

同じ「Markdownファイルを使う仕組み」でも、
やっていることは本質的に真逆です。

画像
Skillsで分離
「分離されたコンテキスト」が何を守っているか
Taskごとにコンテキストを分ける意味は、雑に言うとこの2つです。

メインエージェントの「思考の質」を守ること

余計な履歴やログを極力持たせない

「次に何をするか」「この結果はOKか」を判断するための情報だけ残す

ワークフローを長時間・高負荷でも安定して回せるようにすること

リサーチでどれだけトークンを使っても、他のフェーズに影響させない

長いプロジェクトでも、途中でコンテキスト崩壊しない

ここまでを一言でまとめるなら、

Skillsがやっているのは「指示を追加すること」ではなく、
コンテキストをフェーズごとに切り分けて、“汚さない”こと

です。

「スラッシュコマンドと何が違うの？」という問いに対して、
機能一覧を並べて説明しても、あまりピンとこないのはここが抜け落ちているからだと思っています。

画像
次の章では、その要となる skills/agents/*.md を、「サブエージェント定義」ではなく「Task仕様書」としてどう設計するべきかを、具体的に掘っていきます。

第4章　.claude/agents と skills/agents の「読み込まれ方」の違い
ここをちゃんと整理しておかないと、Skillsの設計を平気でミスります。

一見すると、

.claude/agents/*.md

skills/agents/*.md

どっちも「エージェントの指示を書くMarkdownファイル」に見えます。

でも、本当に重要なのは「どこに置いているか」じゃなくて、

その中身が“いつ”“どのコンテキストに”読み込まれるか

ここです。

この章では、その差分だけにフォーカスして整理します。

.claude/agents/*.md は「セッションの土台として常駐する」
まず .claude/agents/*.md。

ここにエージェントを定義すると、そのエージェントのメタデータはセッション開始時点で、メインのコンテキスト側に含まれます。

つまり、

このエディタ / このプロジェクトで

どんなエージェントがいて

それぞれどんな役割・口調・前提を持っているか

といった情報は、会話が始まる段階から「前提」として抱えられている。

なので .claude/agents に書くものは、性質的に

長く生きる

いろんなタスクから参照される

そのセッション全体の“キャスト”として存在してほしい

というタイプのエージェントです。

編集長とか、アーキテクトとか、「このプロジェクトでは常に居てほしいやつ」はこっち側。

skills/agents/*.md は「Taskのための仕様書」だけど、“読み込み先”は同じ
一方で、skills/agents/*.md。

ここに書くのは、あなたも言っていた通り、

「Taskがどう振る舞うか」の仕様書

です。
つまり「サブエージェントの人格コレクション」じゃなくて、「このTaskはこういう前提・入力・出力で動け」という設計図。

ここでややこしいのが、「どのコンテキストに読み込まれるのか」という話。

ここはちゃんと押さえておきたいポイントが2つあります。

Skillが選ばれた時点で、そのSkill配下の定義は“メインのセッション側から”も見えるようになる

.claude/agents 同様、「このSkillの中にこういうTask仕様書があるよ」という情報自体は、メインの流れの中に乗る

ただし、agents/*.md の本文そのものは「Taskが実行される直前」にロードされる

つまり、「Skillが候補に上がった瞬間」に全部読み込まれるわけではない

Taskごとに「今走らせるやつ」の仕様書だけが読まれる

ここが .claude/agents との一番の差です。

.claude/agents は、セッション開始時点でまとめて前提として抱え込む。
skills/agents は、「そのSkillが呼ばれたあと」「さらにTaskを実行する直前」に、そのTask用の仕様として読まれる。

どちらも「メインのやりとりのコンテキストからアクセスされる」けど、
読み込まれるタイミングと単位がまったく違う。

画像
SubAgentとTaskエージェントの違い
Skillsの「段階的ロード」と agents/*.md の関係
Skillsにはよく出てくるあれ、

Discovery

Loading

Execution

という段階ロードの考え方があります。

ここで勘違いしがちなのが、

「agents/*.md も、この3段階で徐々に読まれていくんでしょ？」

という理解。

ここははっきりさせておくと、

Discovery で使うのは「Skillのメタデータ」まで

Loading で読まれるのは基本的に SKILL.md

skills/agents/*.md は、「Execution段階で、そのTaskを実行する直前にまるっと読まれる」

つまり、

agents/*.md の中身は“段階的には”ロードされない

です。

Taskを起動すると決まった瞬間に、そのTask仕様書の本文はまとめてコンテキストに入る。
だからこそ、ここを重くしすぎると一気にトークンを食うし、Skillsの「コンテキスト効率の良さ」を自分で殺すことになる。

.claude/agents と skills/agents をどう使い分けるか
ここまで踏まえると、実務的な使い分けはかなりシンプルです。

.claude/agents（Sub Agent）

セッションの最初から最後まで、ずっと居てほしいキャラ

プロジェクト全体を横断するロール

その分、数やサイズを増やしすぎると、最初からコンテキストを圧迫する

skills/agents

特定のSkillの中だけで必要な Task の仕様書

「このTaskを実行するときだけ読み込めばいい情報」を書く場所

Task実行直前に全文読まれるので、なるべく“設計”中心にして重くしすぎない

ここで意識したいのは、

.claude/agents に置いた瞬間、その情報は「そのセッションの全タスクの前提」になる
skills/agents に置いたものは、「そのSkillの、そのTaskを実行するときだけ前提」になる

という切り分けです。

画像
段階的ロードから見るSubAgentとSkills Task
agents/*.md に書くときの設計のポイント
なので、skills/agents/*.md に書くときに僕が意識しているのはこんな感じです。

役割・入力・出力・制約を書く

参照する知識はパスを書くに留める（中身は references/ 側に逃がす）

「何を返さないか」も明記する

ファイル自体はできるだけ軽くする

さっきまでの例を少し調整すると、こんなイメージです。

# 本文執筆エージェント

あなたは技術記事作成ワークフローの **Step 4: 本文の作成** を担当する専門エージェントです。

## 責務

アウトラインを元に、**セクションごとにタスクを細分化し、1 つずつ順番に**質の高い本文を執筆する。

- アウトラインを読み込み、各セクションをタスクとして細分化する
- 1 セクションずつ順番に執筆し、完了を確認してから次に進む
- 一度に全セクションを執筆せず、ステップバイステップで進める

| AI 的（避ける）          | 人間らしい（目指す）          |
| ------------------------ | ----------------------------- |
| 箇条書き 3 つで終わり    | 結論 → 理由 → 具体例の流れ    |
| 1 文の段落が連続         | 3-5 文で 1 つの考えをまとめる |
| 「適切に設定する」       | 具体的な設定値を示す          |
| 「様々な〜」             | 具体的に列挙する              |
| 「〜することができます」 | 「〜できる」                  |

## 実行内容（ステップバイステップ）

### Phase 1: 準備とタスク細分化

1. **前ステップの読み込み**

   - `articles/{slug}/02-resources.md` - 活用情報
   - `articles/{slug}/03-outline.md` - アウトライン

2. **セクションごとの執筆**

   - PREP 法: Point（結論）→ Reason（理由）→ Example（具体例）→ Point（まとめ）
   - 1 段落は 3-5 文でまとめる
   - 専門用語は初出時に簡潔に説明

3. **執筆品質の確保**
   - コード例は実際に動作するものを記載
   - 読者への問いかけや「あなた」を適度に使う
   - 次のセクションへの橋渡しを意識

## 入力

- **活用情報**: `articles/{slug}/02-resources.md`
- **アウトライン**: `articles/{slug}/03-outline.md`
- **出力先**: `articles/{slug}/04-draft.md`

## セクションごとの執筆フロー

各セクションで以下を実行：

1. そのセクションで伝えたい **結論を最初に書く**
2. なぜそう言えるのか **理由を 3-5 文で説明**
3. **具体例・コード・数値** で裏付ける
4. 次のセクションへの **橋渡し** を意識

## 出力形式

````markdown
---
title: { 記事タイトル }
---

# {記事タイトル}

## はじめに

{導入文 - 問題提起から始める}

{なぜこの記事を書いたか、読者が得られる価値}

{記事の概要・構成の説明}

## {本論セクション 1}

{結論を最初に}

{理由の説明 - 3-5 文で 1 段落}

{具体例やコード}

```{言語}
// 実際に動作するコード例
```
````

````

{補足説明や注意点}

## {本論セクション2}

...

## 実践・具体例

{ステップバイステップの手順}

1. **{ステップ1タイトル}**

   {詳細な説明}

   ```{言語}
   // コード例
   ```

2. **{ステップ2タイトル}**
   ...

## まとめ

{記事の要点を整理 - 箇条書きだけで終わらせない}

今回の記事では、{テーマ}について{何を}解説しました。

重要なポイントは以下の3つです：

1. **{ポイント1}**: {1-2文の説明}
2. **{ポイント2}**: {1-2文の説明}
3. **{ポイント3}**: {1-2文の説明}

## おわりに

{読者への語りかけ - 次のアクションを促す}
```

## 参照リソース

執筆中は以下を参照すること：
- `references/writing-examples.md` - 良い例・悪い例のサンプル

## 注意事項

### 執筆プロセスに関する重要事項

- **一度に全セクションを執筆してはいけない** - 必ず1セクションずつ順番に執筆する
- **各セクションの執筆前に、どのセクションを執筆するか明確に宣言する**
- **各セクションの執筆完了後、完了を宣言してから次のセクションに進む**
- タスクを細分化し、1つずつ完了させていくことを意識する

### 執筆品質に関する注意事項

- **絶対に箇条書き3つだけで終わるセクションを作らない**
- **1文だけの段落を連続させない**
- 「様々な」「適切に」など抽象表現を避け、具体的に書く
- 「〜することができます」→「〜できる」に統一
- 著者の視点「私の経験では」「実際に試したところ」を入れる
```
````


copy
中身そのものはメインのセッションにも読み込まれるけれど、
「Task直前に」「この1ファイルだけ」読まれる前提で設計している、という意識です。

まとめると、この章で押さえておきたいのはこの2つだけです。

.claude/agents は「セッションの土台として最初から常駐するエージェント定義」

skills/agents は「Skillの中でTaskを実行する直前に読まれる“仕様書”であり、段階的ロードの対象にはならないので軽く設計する必要がある」

ここが整理できていれば、
「サブエージェントって結局どこに書くのが正解なんだっけ？」というモヤモヤはだいぶ消えるはずです。

次の章では、この Task 仕様書とセットになる references/ 側の設計、
つまり「知識をどこまで外部化するか」という話に移っていきます。

第5章　references/ は「知識をぶち込む場所」じゃなくて「外部ストレージ」
agents の話が整理できたので、次は references/ に触れていきます。
特にありがちなのが、

「Taskの仕様書（agents/*.md）の中に、ノウハウもテンプレも全部詰め込む」

というやり方です。
これをやると、正直いってほぼ自爆です。

本来 references/ が担う役割は、

「Taskが必要なときにだけ、取りに行く知識の置き場」

です。
常にコンテキストに載せておくものではなく、「必要な瞬間にだけ読む教科書」という感覚で扱った方がいい。

なぜ「知識を外部化」しないと詰むのか
具体例で見た方が早いので、技術記事ライティングの Skill をもう一度引きます。

最初に自分がやらかした構成は、だいたいこんな感じでした。

agents/article-writer.md の中に

文体ルール

記事構成テンプレ

SEOの基本方針

良い例・悪い例の本文
を全部書く

結果どうなったかというと、この 1 ファイルだけで 8000 トークン超え。

Taskが「執筆フェーズに入ります」となった瞬間、
この 8000 トークンが一括でコンテキストに載る。

そこからさらに、

下書きを何回も書き直す

部分リライトを繰り返す

とやっていると、Task側のコンテキストは簡単にパンクします。
「途中から文章の一貫性が崩れ出す」「急に雑になる」みたいな不具合は、ここから生まれがちです。

本当は、

「どう書くべきか」というルールや例

「今回の原稿」そのもの

は、同じコンテキストに常駐させる必要がないんですよね。

画像
知識を外部化しよう
そこで出てくるのが references/ です。

references/ を「教科書置き場」として設計する
references/ に置くべきものはシンプルで、

文体ルール・ガイドライン

テンプレート

参考用のサンプル

そのSkillで頻繁に参照したい長めのドキュメント

ざっくりこの辺りです。

ディレクトリ構成で書くと、例えばこんな感じになります。

.claude/skills/tech-article-writer/
  SKILL.md
  agents/
    article-writer.md
  references/
    writing-guide.md          # 文体ルール
    structure-templates.md    # 構成テンプレ
    seo-guidelines.md         # SEOの方針
    examples/
      good-article.md         # 良い記事の例
      bad-article.md          # 悪い記事の例

copy
ここで大事なのは、agents 側には中身を書かないことです。
書くのは「どのタイミングで、どのファイルを参照すべきか」だけ。

例えば agents/article-writer.md はこういう書き方にします。

# 執筆 Task 仕様書

## あなたの役割
リサーチ結果をもとに、技術記事の本文を書く。

## 入力
- リサーチ Task から渡された要約
- 想定読者
- 記事の目的

## 作業の前に読むもの
- references/writing-guide.md（文体のルール確認）
- references/structure-templates.md（構成の候補を決めるとき）

## 必要に応じて読むもの
- references/examples/good-article.md（クオリティを確認したいとき）

## 出力
- 完成した記事本文
- 使用した構成パターンのメモ

copy
Task が動くときにコンテキストへ入るのは「この仕様書」と「その時点で参照した references の中身」だけです。

“必要になったときだけ教科書を開いて読む” という使い方にすることで、
コンテキストの消費をかなり抑えられます。

references/ を設計するときのポイント
設計のコツも整理しておきます。

ひとつは、1ファイル1トピックにすること。

文体ルール

構成テンプレ

SEO方針

サンプル記事

これを全部 1 ファイルに詰め込むと、それを読んだ瞬間に数千トークンが飛ぶ。
「今回はSEO気にしなくていい記事」でも、SEOルールごと読み込んでしまう。

なので、

writing-guide.md → 文体だけ

structure-templates.md → 構成だけ

seo-guidelines.md → SEOだけ

みたいに完全に分けておく。

もうひとつは、「いつ読むべきか」を Task 側で指定しておくこと。

作業前に絶対読むもの

品質チェックのときだけ読むもの

条件付きで読むもの（長文になるときだけ、など）

これを agents/*.md に書いておくと、
モデル側も「毎回全部読む」より、必要なタイミングにだけ読むよう寄せてくれる。

そして三つ目は、具体例は別フォルダに逃がすこと。

良い例・悪い例・ケーススタディはめちゃくちゃ役立つんですけど、とにかくトークンを食います。
なので references/examples/ 配下に分離しておいて、

デフォルトでは読まなくていい

本当に迷ったときだけ開く

くらいの扱いにしておくとバランスがいいです。

画像
知識を構造化
なぜ「知識をTask仕様書に書き込むと死ぬ」のか
ここまでの話を一言にすると、

Task仕様書は「どう動くか」だけ書き、
「何を知っているべきか」は references 側に逃がす

という設計にしておかないと、
Taskを増やした瞬間にコンテキストが破綻する、ということです。

agents/*.md に知識も例も全部突っ込むと、

Task実行直前に、その 1ファイル分が丸ごと読まれる

それを Task の数だけ繰り返す

その上で、実際の会話ログ・下書き・差分・検証結果が積み上がっていく

という構造になるので、マジで持たない。

一方で、

agents/*.md → 「仕様だけ」

references/ → 「必要になったときにだけ読む知識」

という分担にしておくと、

Taskごとのコンテキストサイズが抑えられる

長いワークフローでも安定する

知識の再利用性も上がる（複数 Task から同じ references を参照できる）

というメリットが出てきます。

まとめると、references/ は

ノウハウをとりあえず突っ込むフォルダではなく

「Taskが必要な瞬間にだけ開く教科書を、トピックごとに分けて置いておく棚」

というイメージで設計するのがちょうどいいです。

画像
知識はTask仕様書に書き込まない方がいい
次の章では、この「Task仕様書」と「外部化された知識」に、scripts を組み合わせたときに何が起きるか。
つまり、Skillsが「ただの指示集」から「自動化装置」に変わるポイントを整理していきます。

第6章　scripts/ を入れた瞬間、Skillsは「考えるだけじゃなく動く」
Task と references の話までは「コンテキストの設計」の話でした。
ここから一段ギアを変えていきますw

Scripts を噛ませた瞬間に、Skillsは

「うまく考えてくれるアシスタント」

から

「考えて → 手を動かすとこまでやる自動化装置」

に変わります。

ここをちゃんと分けて理解しておかないと、
LLMに「向いてない仕事」まで延々やらせてトークンだけ溶かすことになる。

LLMにやらせるとコスパが悪い仕事
当たり前なんですが、LLMは何でも屋ではありません。

特に相性が悪いのは、こういうやつです。

大量のファイルを機械的にいじる処理

ログやCSVの集計・変換・分析

こういうのをプロンプトだけでやろうとすると、

無駄にトークンを食う

たまにミスる

再現性が低い

という、まあまあ最悪な三点セットになります。

ここで scripts/ の出番です。

scripts/ の役割は「決まった作業を外出しする」こと
Skills における scripts/ は、

「LLMにやらせると微妙な定型処理を、コードとして切り出しておく場所」

という立ち位置です。

一度 Python に落として scripts/format_article.py にしておけば、
以降は「スクリプトを回して」と指示するだけで済みます。

ざっくり雰囲気だけ書くと、こんな構成です。

#!/usr/bin/env python3
"""
記事Markdownを整形するスクリプト
- 見出しレベルの整理
- 文末の句読点統一
- 連続した空行の圧縮
- 画像パスを相対パスに変換
"""

import re
import sys
from pathlib import Path

def normalize_headings(text: str) -> str:
    # h1 は最初の1つだけ、それ以外の # はレベルをずらす…みたいな処理
    lines = text.split("\n")
    result = []
    seen_h1 = False

    for line in lines:
        if line.startswith("# ") and not seen_h1:
            seen_h1 = True
            result.append(line)
        elif line.startswith("# "):
            result.append("#" + line)  # 2つ目以降の h1 を h2 に落とすイメージ
        else:
            result.append(line)

    return "\n".join(result)

def normalize_punctuation(text: str) -> str:
    # 文末の"."や"．"を「。」に寄せるなど
    return re.sub(r"[\.．](\n|$)", r"。\1", text)

def compress_blank_lines(text: str) -> str:
    # 3連続以上の改行を2つに圧縮
    return re.sub(r"\n{3,}", "\n\n", text)

def convert_image_paths(text: str, base_dir: Path) -> str:
    # 画像パスが絶対パスなら、可能なものは相対パスに直す
    def repl(match):
        alt = match.group(1)
        path = Path(match.group(2))
        if path.is_absolute():
            try:
                rel = path.relative_to(base_dir)
                return f"![{alt}]({rel})"
            except ValueError:
                return match.group(0)
        return match.group(0)

    return re.sub(r"!\[(.*?)\]\((.*?)\)", repl, text)

def main(file_path: str) -> None:
    p = Path(file_path)
    content = p.read_text(encoding="utf-8")

    content = normalize_headings(content)
    content = normalize_punctuation(content)
    content = compress_blank_lines(content)
    content = convert_image_paths(content, p.parent)

    p.write_text(content, encoding="utf-8")
    print(f"Formatted: {file_path}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: format_article.py <file_path>")
        sys.exit(1)
    main(sys.argv[1])

copy
中身は別にこの通りである必要はないですが、ポイントはこうです。

一回スクリプトを書いてしまえば、動作は毎回同じ

どれだけ回してもトークン消費はゼロ

LLM側は「実行してね」と指示するだけ

つまり、「考える」は LLM、「手を動かす」は Taskまたは、Script、という分業になります。

画像
ScriptsのPythonで定型化しよう
SKILL.md から scripts をどう扱うか
実際の運用では、SKILL.md に「どこで scripts を挟むか」を書いておきます。

例えば、記事作成ワークフローなら、流れはだいたいこうなるはずです。

Taskでリサーチ

Taskでドラフト執筆

scripts で Markdown 整形

Taskで最終チェック

SKILL.md では、それをそのまま手順として書きます。

## Step 4: 記事の整形

執筆 Task が生成したドラフトファイル（`articles/draft.md`）に対して、
以下のスクリプトを実行して整形すること：

```bash
python scripts/format_article.py articles/draft.md

copy
LLM側から見たときに、

「これは自分で文章を書いたり直したりするフェーズ」

「これはスクリプトを叩いて機械処理するフェーズ」

が明確に分かれている状態になります。

LLM × references × scripts の役割分担
ここまで整理してきた

Task（agents/*.md）

references/

scripts/

は、それぞれ役割が違います。

ざっくり分解すると、こういう感じです。

LLM（Task）

判断する

文章を書く

方針を決める

references/

その判断のための知識・ルール・テンプレを置いておく

必要なときだけ読ませる「外部ストレージ」

scripts/

機械的・決定的な処理を担当する

ファイル操作・整形・変換などを確実にやる

ここまで来ると、Skills はもう「プロンプトの塊」ではなくなります。

SKILL.md でワークフローの流れを定義し

agents/*.md で Task ごとの役割を切り分け

references/ に知識を逃がし

scripts/ に手作業を押しつける

この4つが揃って、ようやく

「Task × Context × Automation」をまとめて扱える仕組みとしての Skills

になります。

画像
Skillsでscriptsをどう使うか
次の章では、この全体像が Anthropic の公式ドキュメントやベストプラクティスとどう接続しているかを整理しつつ、「Skillsはただの“高級スラッシュコマンド”ではない」という話をもう一度、設計思想レベルまで引き上げてまとめていきます。

第7章　公式Best Practicesとの接続を整理する
ここまで割と「実務でこう使う」という視点で話してきたので、ここで一度だけ、公式ドキュメント側の整理とつなげておきます。

「自分の理解が独自解釈になってないか」くらいの位置づけです。

Skillsを公式の言葉で整理し直す
Anthropicの説明を冷静にかみ砕くと、Skillsはだいたいこんな扱いになっています。

Skills = instructions（指示）＋ scripts（スクリプト）＋ resources / references（リソース・知識）の束で、Claudeの能力を拡張するもの

ここまでこの記事で分解してきた

SKILL.md

agents/

references/

scripts/

は、それぞれこの公式の言い方ときれいに対応しています。

instructions: ワークフロー全体の定義 & Task仕様書 (SKILL.md, agents/)

resources / references: ルール・テンプレ・サンプルなどの知識 (references/)

resources/scripts: コマンド・自動化処理 (scripts/)

つまり、この記事でやってきたのは、公式の抽象的な説明を「どのフォルダに何を書くか」という粒度まで落とし込んだだけです。

段階的ロードと「どこまでが対象か」
もう一つ、公式側で強く語られているのが、Skillsの「段階的ロード（Progressive Disclosure）」です。

ざっくり整理すると、Claude側の動きはこんなイメージになります。

まず各Skillの「メタデータ」だけを見る

関係ありそうなSkillが見つかったら、そのSkillの SKILL.md を読む

SKILL.md を読んだうえで、「このTaskを実行しよう」と決まったタイミングで、その Task に対応する agents/*.md や、必要な references/ を読む

ここでポイントになるのが、

段階ロードの主役はあくまで「メタデータ」と「SKILL.md」

skills/agents/*.md は、「Taskを実行すると決めた瞬間にまとめて読まれる」側

という線引きです。

なので、

SKILL.md

そこそこ長くてもいいが、無駄に巨大にする必要はない

「このSkillはどんなタスクを、どんな流れで処理するのか」が書いてある中枢

skills/agents/*.md

段階ロードの“候補探索”には使われない

実行直前に、その Task の仕様書として一気に読まれる

だからこそ「仕様だけを書く」「知識は references に逃がす」が効いてくる

この記事でやってきた「agents は軽く設計して、知識は references に外出しする」という方針は、
この段階ロードの設計にだいぶ沿っています。

画像
構造化と段階的ロード
公式が強調している「自動で呼ばれる専門家」という考え方
Anthropic側の説明で、個人的にいちばん腑に落ちるのが、

Skills は「必要になったときに自動で召喚される専門家の束」

というニュアンスです。

ここまでの整理と合わせると、

.claude/agents（Sub Agent）

ずっと同席している「このプロジェクト全体のメンバー」

Skills

あるタスクが来たときに

メタデータと SKILL.md を見て「たぶんこのSkillだな」と判断され

中で定義された Task仕様（agents）、知識（references）、スクリプト（scripts）が
必要な順番で呼び出される「期間限定のチーム」

という構造になっています。

ここから先の設計の重心は、もう「プロンプトの工夫」だけじゃない。

どんな Task に分割するか

どのタイミングでどの Skill を候補に上げるか

どのフェーズで何を参照させるか

どこを scripts に切り出すか

といった、ほぼ「システム設計」のレイヤーに移っている。

公式が言う「Skills = 機能拡張」という言葉だけを拾うと、
単なる“高機能プリセットプロンプト”くらいのイメージで止まりがちですが、
ここまで分解してくると、

Skillsは「Task設計 × コンテキスト設計 × 自動化設計」をひとまとめにするフレームワーク

として見る方が、だいぶしっくり来ます。

Context Engineeringとの接点
Context Engineering側の文脈でよく語られているのは、

ちゃんとしたモデルなら、だいたいのことは「コンテキストさえ良ければ」できる

逆に、多くのエージェントの失敗は「モデルの性能」ではなく「文脈の設計ミス」

という話です。

この記事で扱った

Taskによるコンテキストの分離

agents による「役割・入力・出力」の明示

references による知識の外部化

scripts による定型処理の切り出し

は、全部ここにつながります。

乱暴に一言でまとめると、

モデルを賢くしようとする前に、
「いつ、何を、どこまで見せるか」を設計する方がリターンが大きい

ということです。

Skillsは、その「いつ・何を・どこまで」の設計を、
フォルダ構造とファイル単位にまで落とし込んだ仕組みだと捉えると、
公式ドキュメントで言っていることと、実務でやるべきことがきれいにつながります。

画像
構造とコンテキスト
次の章では、ここまでの話を全部束ねて、
「結局、Skillsをどう設計すれば“スラッシュコマンドの延長”から抜け出せるのか」をまとめていきます。

第8章　結論：Skillsは「コンテキスト設計のフレームワーク」
ここまで長々と分解してきたので、いったん全部まとめ直します。

最初の問いは、「Skillsってスラッシュコマンドと何が違うの？」でした。

見た目だけを比べると、たしかにどちらも

事前に定義した指示を

LLMに読み込ませて

特定のタスクを実行させる

という意味ではよく似ています。

ただ、ここまで見てきたとおり、両者は「どんな機能があるか」ではなく、

タスクをどう分解し、
そのタスクに「いつ・何を・どこまで」見せるかを設計するか

というレイヤーでまったく別物になっています。

Skillsを「スラッシュコマンドの強化版」としか見ないと、ほぼ何も始まらない
スラッシュコマンドは、本質的には

「メインセッションのコンテキストに、決め打ちのプロンプトを追加する仕組み」

です。

どれだけ凝った Markdown を書いても、
やっていることは「保存されたプロンプトを貼る」の延長上にあります。

一方で、ここまで整理してきた Skills はこういう構造でした。

.claude/agents

セッション全体で“常駐”させたいエージェント定義

メインのコンテキストに、最初から乗っている前提情報

SKILL.md

特定の種類のタスクに対する「ワークフローの中枢」

どんなフェーズをどの順番で進めるか、という流れの定義

skills/agents/*.md

各 Task が「どう振る舞うか」の仕様書

Skill 適用後、「その Task を実行する直前にだけ」読まれる設計

だからこそ、役割・入力・出力・制約だけを書き、知識は持たせすぎない

references/

ルール・テンプレ・サンプルなど、「必要なときだけ取りに行く知識」の外部ストレージ

1ファイル1トピックで分解し、「いつ読むか」を Task 側で指定する

scripts/

ファイル操作や整形など、LLMにやらせるとコスパが悪い処理を外出しする場所

「判断はLLM、機械的な作業はコード」に分業するための実行部品

ここまで揃えたうえでようやく、

Skills = Task設計 × コンテキスト設計 × 自動化設計を束ねるフレームワーク

と言える状態になります。

「SKILL.md に長めのプロンプトを書いて便利に呼び出す」だけで終わると、
この全体像のごく一部しか使っていない、ということです。

コンテキストの質が、エージェントの上限を決める
Context Engineering でずっと言われている通り、最近のフロンティアモデルは、

“賢さ”そのものはもう十分高く

失敗のかなりの割合は「コンテキストの設計ミス」から生まれている

という状態になっています。

この記事の中で扱った

Taskごとにコンテキストを分離する

agents には仕様だけを書き、知識は references に逃がす

scripts に機械処理を追い出して、LLMは判断と生成に集中させる

というパターンは、全部ここに直結しています。

雑に言ってしまえば、

モデルを変えたり、プロンプトを盛ったりする前に、
「何をどこまで一緒に読ませるか」を整理した方が、結果が変わりやすい

ということです。

Skillsは、その「整理」をファイル構造レベルまで落としてくれる道具になっています。

画像
Skillsから学ぶコンテキスト設計
実務でSkillsをちゃんと使うための最低限のステップ
じゃあ、実際に自分のプロジェクトで Skills を使うとしたら、何から始めるか。

細かいパターンはいくらでもあるので、ここでは最低限のステップだけを書きます。

まずは、扱いたいタスクをひとつ決めて、それを分解します。

例：技術記事を書く

リサーチ

アウトライン作成

本文執筆

整形・フォーマット

最終レビュー

このとき、いきなり全部を 1 つのエージェント・1 つの Skill でまとめて処理させようとしない方がいいです。
むしろ逆で、「どこで Task を区切るか」を先に決めます。

そのうえで、

SKILL.md に「ワークフロー全体の流れ」を書く

各フェーズを Task として切り出し、それぞれに skills/agents/*.md を用意する

役割 / 入力 / 出力 / 返さないもの をきっちり言語化する

Taskごとに必要な知識・ルール・テンプレを、references/ 側へ逃がす

1ファイル1トピックで分解

「作業前に絶対読む」「チェックのときだけ読む」を仕様書に明記する

明らかに「LLMにやらせると面倒な処理」は、scripts/ でPythonコードに落とす

この流れで 1 個 Skill を組むだけでも、

スラッシュコマンド的な「保存されたプロンプト」の世界から、「Task単位で設計されたワークフロー」の世界に一段上がる

感覚がかなりはっきり感じてます。

Skillsを使うということは、「自分の思考を構造化して外に出す」ということ
最後に、少しだけ抽象度の高い話をして締めます。

Skillsを真面目に設計しようとすると、どうしても避けられない作業があります。

このタスクの「区切り」はどこか

ここで何を入力として受け取り、何を出力として返すのが妥当か

どの知識は毎回必要で、どの知識は「必要になったときだけ」で良いか

何を人間の思考に任せて、何を機械処理として外出しすべきか

これって、結局

自分の頭の中にある暗黙の判断基準や、作業フローの癖を、
言語化して構造に落とすプロセスそのもの

なんですよね。

スラッシュコマンドの世界では、

「なんとなくいつもやっている指示」を

ちょっときれいな文章にして保存しておく

くらいで終わることが多い。

Skillsをきちんと設計するというのは、それとは違って、

自分の思考と作業を Task に分解して

それぞれに仕様書を書き

知識と作業を外部に逃がし

それを「誰が見ても再現できる形」にしておく

というところまで踏み込むことになります。

つまり、

Skillsは「LLMを便利にする機能」というより、
自分の思考プロセスを“インフラ化していくための器”

として扱った方が、長期的にはリターンが大きい。

スラッシュコマンドに見えてしまうのは、ほとんどの場合、
こちら側が「そこまで設計していない」だけです。

Skillsの本質は機能差じゃなくて、「設計レベルの切り替え」とにあります。
Task・コンテキスト・知識・自動化をひとまとまりで扱えるかどうか。
そこを意識して使い始めると、「スラッシュコマンドとは別物だな」という感覚が、かなりはっきり見えてくるはずです。

画像
自分の思考を構造化して外に出す
Skillsは「再利用可能なコンポーネント」として設計されている
もうひとつ、Skillsをわざわざ触る意味としてかなり大きいのがここです。

Skillsは最初から「再利用前提のコンポーネント」として設計されている。

スラッシュコマンドは、基本的に

そのエディタ

その環境

その1プロジェクトの中

で完結しがちな「ローカル便利機能」です。
良くて「同じエディタを使っている自分の別プロジェクト」で再利用できるくらい。

Skillsは最初から発想が逆で、

.claude/skills/〜 という、ツール側が標準で見る場所に置かれる

SKILL.md / agents / references / scripts というディレクトリ構造が固定で、API経由でも読める

Claude Code だけじゃなく、Cursor・API・将来の別クライアントからも“同じSkill”を叩ける前提で設計されている

つまり、一度ちゃんと設計してしまえば、

「特定のプロジェクトの中でしか使えないプロンプト」ではなく、
「自分の“思考 + 作業フロー”をパッケージ化したライブラリ」

として扱える。

例えば「技術記事ライティングSkill」を作ったとき、
その中身は単なる文章テンプレではなく、

リサーチ Task の仕様

執筆 Task の仕様

レビュー Task の仕様

記事構成のテンプレ

文体ルール

整形用スクリプト

まで含めた、ひとつの「ライティングモジュール」になる。

このモジュールは、環境が変わっても中身は変わらない。

Claude Code から使っても

Cursor から使っても

「同じSkill」を叩けば、
同じワークフロー / 同じ基準 / 同じアウトプット構造で動く。

しかも、構造が分かれているおかげで、メンテも差し替えもやりやすい。

文体だけ変えたければ references/writing-guide.md を差し替える

新しいチェックフローを足したければ、Taskと scripts を1個追加する

逆に、別のSkillから同じ references や scripts を参照することもできる

プロダクト的に言えば、完全に「コンポーネント設計」です。
同じ「Skill」を、複数のプロジェクト・複数のクライアント・複数の用途から叩き回せる。

これを「スラッシュコマンドに毛が生えた程度」と見ている時点で、だいぶ損している。

画像
Skillsは再利用可能なコンポーネント
第9章　まとめ：Skillsの本当の価値
最後に、この記事全体をまとめる形で、Skillsの価値をひとことで雑に集約すると、

Skills =
「Task単位でコンテキストを設計し、
知識と作業を外部化したうえで、
それを再利用可能なコンポーネントとして束ねる仕組み」

という話になります。

スラッシュコマンドと比較して見える差は、
機能の数やUIの違いではなく、

コンテキストをどう扱うか

タスクをどう分割するか

その設計をどこまで再利用可能な形で固定するか

というレイヤーの話です。

SKILL.md にちょっと長めのプロンプトを書いて満足しているうちは、
Skillsのポテンシャルの半分も触れていない。

Task・agents・references・scripts まで使い切った瞬間から、
「スラッシュコマンドと何が違うの？」という問い自体が、
だんだん意味を失っていきます。

そこまで設計して初めて、Skillsは「単なる便利機能」から
「自分の思考と作業フローをインフラ化するための設計フレームワーク」に変わる。

差分はそこです。

画像
コンテキスト設計のフレームワーク
おわりに：エージェント戦略を考えるのが好きな人へ
ここまで読んでくれた時点で、だいぶマニア側の人間だと思いますwww

僕はXで「AI×自動化」と「エージェント設計まわり」の実験ログをひたすら垂れ流しています。
この記事みたいな話を、もっとラフに・もっと頻度高く見たい人は、フォローしておいてもらえると、そのうちどこかのタイミングで必ず回収できるはずです。


学生・若手向けのコミュニティ「gakuse.ai」でも、Skillsやエージェント設計を実務ベースで試す場づくりをしています。
「自分もこういう設計を一緒にやりたい」「実案件レベルで触りたい」という人は、タイミング合うときにぜひ覗きにきてください。

感想・質問・ツッコミがあれば、noteのコメントか X 宛に気軽に投げてもらえれば拾います。
スラッシュコマンドで満足している世界線から一歩外に出たい人の相談なら、だいたい歓迎です。

良いお年を〜

高評価して応援しよう！

高評価

Kyutaro
もりおき
Yoshiaki@10B
tatsu
4人
#AI
#Claude
#AIエージェント
#Anthropic
#AI駆動開発
#コンテキスト
#agent
#コンテキストエンジニアリング
#skills
#AgentSkills

46

2



この記事が気に入ったらチップで応援してみませんか？


チップで応援
そら ☁️ Dify 自動化オタク📱
そら ☁️ Dify 自動化オタク📱

フォロー中
フォローすると最新記事が届きます！｜学生AIコミュニティgakuse.ai 代表｜21歳 生成AI発信者エンジニア＆大手新卒SE←東京高専卒｜令和の虎 完全ALL｜国会議員会館で登壇｜高専でAIの授業｜地上波TV出演｜第1回Dify公式コンテスト受賞🏆
買うたび 抽選 ※条件・上限あり ＼note クリエイター感謝祭ポイントバックキャンペーン／最大全額もどってくる！ 12.1 月〜1.14 水 まで

46


noteプレミアム
note pro
よくある質問・noteの使い方
プライバシー
クリエイターへのお問い合わせ
フィードバック
ご利用規約
通常ポイント利用特約
加盟店規約
資⾦決済法に基づく表⽰
特商法表記
投資情報の免責事項
Agent Skillsはスラッシュコマンドじゃないって。 ｜そら ☁️ Dify 自動化オタク📱