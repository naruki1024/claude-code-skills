# TDDの原則

## TDDの3つの原則（厳守）

1. **失敗するテストなしに本番コードを書かない**
2. **失敗させるために必要な分だけテストを書く**
3. **テストを通すために必要な分だけ本番コードを書く**

## Red-Green-Refactor サイクル

```
Red（失敗）
  ↓ テストを書く
Green（成功）
  ↓ 最小限の実装
Refactor（改善）
  ↓ コード品質向上
Red（次のテスト）...
```

## 分解粒度の原則

### 良い分解（テスト可能な単位）

```
- 「講座一覧取得（全件）」 → 1つのQuery関数
- 「カテゴリ絞り込み」 → フィルタロジック単体
- 「複合フィルタ・ソート」 → 組み合わせロジック
- 「ユーザープロフィール取得」 → 単一責務のQuery
```

### 悪い分解（粒度が大きすぎる）

```
- 「講座一覧画面」 → 画面全体は分解不足
- 「CRUD全部」 → 責務が複数混在
- 「マイページ」 → 複数のQueryが含まれている
```

### 分解の目安

| 指標 | 目安 |
|------|------|
| テストケース数 | 5-10個/サブIssue |
| テストファイル行数 | 300行以下 |
| 責務 | 1サブIssue = 1関数 |

## YAGNI原則

> **"You Ain't Gonna Need It"**
>
> 将来必要になるかもしれない機能を今実装してはいけない。

```
✅ 良い実装:
- テストをパスする最小限のコード
- 現在の仕様で必要な機能のみ

❌ 悪い実装:
- 「将来使うかも」という機能
- 過剰な汎用化・抽象化
- 使われないパラメータ
```

## 過剰な実装を避ける

### 避けるべきパターン

1. **過度な抽象化**
   - 1回しか使わないのにジェネリクスを導入
   - 不要なインターフェース定義

2. **先回り実装**
   - まだ仕様にない機能の追加
   - 「念のため」の追加パラメータ

3. **過剰なエラーハンドリング**
   - 起こりえないエラーケースの処理
   - 過度に防御的なコード

## MVP バックエンド実装方針

```
- DB アクセスは `webapp/src/server/<domain>/` に配置
- Drizzle ORM（drizzle-orm/mysql2）を使用
- packages/shared に直接追加しない
- admin からも利用する必要が出たタイミングで昇格を検討
```

## テストが仕様書になる

TDDで書かれたテストは、そのまま仕様書として機能する。

```typescript
describe('getCourseList - 講座一覧取得', () => {
  // これ自体が仕様を表現している
  it('公開中の講座のみが取得されること', ...);
  it('新着順でソートされること', ...);
  it('limit指定で取得件数が制限されること', ...);
});
```
