# Agent Skillsはスラッシュコマンドじゃないって。

> 出典: https://note.com/sora19ai/n/n63d3e459885f
> 著者: そら（福島楓人）- 生成AIエンジニア / gakuse.ai代表
> 公開日: 2025年12月30日

~Task × Context Engineering で見る、Skillsの本当の価値~

## 目次

1. [第1章 「それ、スラッシュコマンドでよくない？」というモヤモヤから](#第1章)
2. [第2章 まず「Taskって何なのか」をちゃんと押さえる](#第2章)
3. [第3章 なぜメインエージェントに「全部」入れちゃダメなのか](#第3章)
4. [第4章 .claude/agents と skills/agents の「読み込まれ方」の違い](#第4章)
5. [第5章 references/ は「知識をぶち込む場所」じゃなくて「外部ストレージ」](#第5章)
6. [第6章 scripts/ を入れた瞬間、Skillsは「考えるだけじゃなく動く」](#第6章)
7. [第7章 公式Best Practicesとの接続を整理する](#第7章)
8. [第8章 結論：Skillsは「コンテキスト設計のフレームワーク」](#第8章)
9. [第9章 まとめ：Skillsの本当の価値](#第9章)

---

## 第1章 「それ、スラッシュコマンドでよくない？」というモヤモヤから {#第1章}

Claude CodeにSkillsが来たとき、タイムラインを見ていて最初に目についたのは、技術的な盛り上がりよりも、「え、これ結局スラッシュコマンドの焼き直しじゃないの？」という空気だった。

- 「/review みたいなコマンドを、Markdownに書いてるだけでしょ」
- 「Cursor以外でも動く"スラコマ"ってこと？」

正直、その感覚は分からなくもない。表面だけ並べると、確かに似ている。

1. あらかじめ指示を書いておく
2. それを呼び出して、Claudeにタスクをやらせる

スラッシュコマンドもSkillsも、この構造だけ見れば同じに見える。違うのはUIと「/」を打つかどうかだけ、という理解になりやすい。

### スラッシュコマンドとSkillsの比較

| 項目 | スラッシュコマンド | Skills |
|------|-------------------|--------|
| 環境 | Cursorの中だけで完結 | Claude Code / Codex / Cursor 将来の実行環境にもまたがって使える |
| 実行タイミング | ユーザーが `/command` を叩いた瞬間に動く | エージェントが「必要だ」と判断したタイミングで自動的に起動 |
| コンテキスト追加 | 指定したMarkdownがそのままコンテキストに「追加」される | メタデータ → SKILL.md → agents / references…と段階的にロード |
| コンテキスト制御 | 「どのタイミングで、何をどれだけ読むか」の制御は弱い | **Task単位でコンテキストを分離し、結果だけをメインに返せる** |

### コンテキストエンジニアリングという視点

「スラッシュコマンドと同じ」に見えてしまうのは、"コンテキストをどう設計しているか"という視点がすっぽり抜けているからだ。

LLMの世界で本当に効いてくるのは、「どんなプロンプトを書いたか」よりも、「どんなコンテキストを、どんな構造で渡したか」だ。

Skillsは、この「コンテキスト設計」を扱うための仕組みとして作られている。スラッシュコマンドの"高機能版"というより、**Context Engineering を最高に実現するためのフレームワーク**として見る方がしっくりくる。

> **実績**: Compactを一回も使わずに1時間駆動し、精度もかなり良かったです。

### Context Engineeringの定義

LangChainが初めに提唱した考え方：

> LLMがタスクをちゃんと完走できるように、「どの情報」「どのツール」を「どのタイミング」で渡すかを設計すること

プロンプトを一発で書き切るのではなく、ワークフロー全体の中で「コンテキストの出し入れ」をデザインする発想。

---

## 第2章 まず「Taskって何なのか」をちゃんと押さえる {#第2章}

Skillsを理解しようとするときに、いきなりSKILL.mdの書き方から入ると高確率でつまずく。最初に整理すべきなのは、もっと地味で、でも根本にある「Task」という概念。

### Taskとは

Taskは、一言でまとめると：

> Claude Code がその場で立ち上げて、仕事が終わったら即解散する「一時労働者」

単発バイトのような存在。「サブエージェント」に近いが、Anthropic公式の説明では：

- 「新しい人格を永続的に増やすものではない」
- 「必要なときだけ起動される、一時的なClaudeのワーカー」

という位置づけ。

### Taskがやっていること

普段、メインのClaude Codeに重めのタスクを投げると、履歴がどんどん溜まる：

- 何個もファイルを開く
- 何度もコードを書き直す
- テストを回す
- ログが積み上がる

全部ひとつのコンテキストに居座り続けるので、気づいたら200kトークンがパンパンになる。

**Taskを使うと、この構造が変わる：**

- 各Taskは「独立した」コンテキストウィンドウを持つ
- 1つのTaskにつき、およそ 200k トークン分の作業領域が与えられる
- 最大で 10 個程度まで並列起動できる
- **Taskが終わると、その中身ごと消えて、結果だけがメインに返る**

メインのエージェントは、あくまで「司令塔」。重たい作業は、別プロセスとしてTaskに丸投げしている。

結果どうなるかというと、**メインエージェントのコンテキストは、最後までスカスカに保てる**。

### 技術記事ライティングを例にすると

```
.claude/skills/tech-article-writer/
  SKILL.md                    # 全体のワークフロー
  agents/
    article-research.md       # リサーチ担当Taskの仕様
    article-outline.md        # アウトライン作成担当Taskの仕様
    article-writer.md         # 執筆担当Taskの仕様
    article-reviewer.md       # レビュー担当Taskの仕様
    article-extract.md        # 抽出担当Taskの仕様
    article-image-planner.md  # 画像計画担当Taskの仕様
    article-image-curator.md  # 画像キュレーション担当Taskの仕様
    article-profile.md        # プロフィール追加担当Taskの仕様
    article-linker.md         # リンク追加担当Taskの仕様
    article-cta.md            # CTA追加担当Taskの仕様
  references/
    author-profile.md         # 著者プロフィールリファレンス
    cta-resources.md          # CTAリソースリファレンス
    image-sources.md          # 画像ソースリファレンス
    note-best-practices.md    # ノートベストプラクティス
    writing-examples.md       # 執筆例リファレンス
```

**ワークフローの流れ：**

1. ユーザーから「この記事を書いて」と依頼が来る
2. SKILL.mdを読んだメインエージェントが、まず「リサーチTask」を起動
3. リサーチTaskは、独立したコンテキストの中で：
   - Web検索を回しまくり
   - 情報を整理し
   - 要約だけをメインに返す
4. リサーチTaskはそこで消える
5. 次に「執筆Task」が起動される
   - 受け取るのは「リサーチの要約」やアウトラインなど、最小限の情報だけ
   - 何度書き直しても、その思考ログは執筆Taskのコンテキストに閉じる
6. 執筆が終わったら、今度は「レビューTask」が立ち上がり、ドラフトをチェック

**ポイント**: フェーズごとに「使うコンテキスト」が完全に入れ替わる。

人間の仕事に置き換えると、情報収集班→ライター→校正・編集が、それぞれ別部屋で作業して、完成物だけ編集長の机に届くような感じ。

### Taskが「コンテキスト設計」の中で持つ意味

OpenAI共同創業者 Andrej Karpathyの比喩を借りると：

| 概念 | 比喩 |
|------|------|
| モデル本体 | CPU |
| コンテキストウィンドウ | 作業用のメモリ（RAM） |
| Task | 別プロセス |

メインのプロセスだけで全部やろうとすると、メモリが足りなくなったり、不要なデータを抱え込みすぎて遅くなったりする。

**設計の違い：**

- スラッシュコマンド = 「保存したプロンプトを一気に流し込む」仕組み
- Task = 「コンテキストを分割して、プロセスごとに使い捨てる」仕組み

見た目は似ていても、やっていることは別物。

---

## 第3章 なぜメインエージェントに「全部」入れちゃダメなのか {#第3章}

エージェントを触っていると、だいたい最初にやりがちなのがこれ：

> 「とりあえず全部コンテキストに突っ込んでおけば、モデルがいい感じに処理してくれるでしょ」

残念ながら、**これが一番事故るパターン**。

最近のフロンティアモデルは、よほど無茶をしなければ「頭が悪くて失敗する」ことはあまりない。多くのケースで本当に起きているのは：

> **モデルがダメなのではなく渡しているコンテキストがダメ**

### コンテキストが壊れる典型パターン

技術記事を書くワークフローを、1つのコンテキストだけで回そうとすると：

1. リサーチで Web ページを 30 個読む → だいたい 5〜6 万トークンくらい飛ぶ
2. 執筆でドラフトを何度も書き直す → さらに数万トークン
3. レビューで修正を重ねる → コメントや差分がまた積み上がる

気づくと、10万トークンくらいは平気で消費している。

**この状態で起きる問題：**

1. **判断が濁る** - 机の上にいらない資料が散乱していると、「どれを見て判断すべきか」を考えるだけでエネルギーを持っていかれる。LLMも同じ。
2. **コンテキスト不足による劣化** - 上限に近づくと、古い情報から順に圧縮・削除される。本当に重要な部分が削られることも普通にある。

### Skillsがやっていることは「情報の追加」ではなく「分離」

Skills前提の設計では：

**メインエージェント（オーケストレーター）:**
- ユーザーの依頼を受け取る
- どのTaskをどの順番で呼ぶかを決める
- 各Taskから返ってきた「要約された結果」だけを持つ

**Skillsで実行されるTaskたち:**
- 独立したコンテキストをそれぞれ持つ
- 自分の中では、Webページを読みまくっても、ドラフトを何度も破棄してもOK
- 仕事が終わったら、必要な結果だけを返してコンテキストごと消える

**本質的な違い：**

| 仕組み | やっていること |
|--------|----------------|
| スラッシュコマンド | メインのコンテキストに「プロンプトや知識を追加する」 |
| Skills + Task | 「処理そのものを別コンテキストに分離して、結果だけ戻す」 |

同じ「Markdownファイルを使う仕組み」でも、やっていることは本質的に真逆。

### 「分離されたコンテキスト」が何を守っているか

1. **メインエージェントの「思考の質」を守る**
   - 余計な履歴やログを極力持たせない
   - 「次に何をするか」「この結果はOKか」を判断するための情報だけ残す

2. **ワークフローを長時間・高負荷でも安定して回せる**
   - リサーチでどれだけトークンを使っても、他のフェーズに影響させない
   - 長いプロジェクトでも、途中でコンテキスト崩壊しない

> Skillsがやっているのは「指示を追加すること」ではなく、コンテキストをフェーズごとに切り分けて、"汚さない"こと

---

## 第4章 .claude/agents と skills/agents の「読み込まれ方」の違い {#第4章}

ここをちゃんと整理しておかないと、Skillsの設計を平気でミスる。

一見すると、`.claude/agents/*.md` と `skills/agents/*.md` どっちも「エージェントの指示を書くMarkdownファイル」に見える。

でも、本当に重要なのは「どこに置いているか」じゃなくて：

> **その中身が"いつ""どのコンテキストに"読み込まれるか**

### .claude/agents/*.md は「セッションの土台として常駐する」

ここにエージェントを定義すると、そのエージェントのメタデータはセッション開始時点で、メインのコンテキスト側に含まれる。

つまり：
- このエディタ / このプロジェクトで
- どんなエージェントがいて
- それぞれどんな役割・口調・前提を持っているか

といった情報は、会話が始まる段階から「前提」として抱えられている。

**`.claude/agents` に書くもの:**
- 長く生きる
- いろんなタスクから参照される
- そのセッション全体の"キャスト"として存在してほしい

→ 編集長とか、アーキテクトとか、「このプロジェクトでは常に居てほしいやつ」

### skills/agents/*.md は「Taskのための仕様書」

ここに書くのは「Taskがどう振る舞うか」の仕様書。「サブエージェントの人格コレクション」じゃなくて、「このTaskはこういう前提・入力・出力で動け」という設計図。

**重要なポイント：**

1. **Skillが選ばれた時点で、そのSkill配下の定義は"メインのセッション側から"も見えるようになる**
   - `.claude/agents` 同様、「このSkillの中にこういうTask仕様書があるよ」という情報自体は、メインの流れの中に乗る

2. **ただし、agents/*.md の本文そのものは「Taskが実行される直前」にロードされる**
   - 「Skillが候補に上がった瞬間」に全部読み込まれるわけではない
   - Taskごとに「今走らせるやつ」の仕様書だけが読まれる

**これが .claude/agents との一番の差：**

| 配置場所 | 読み込みタイミング |
|----------|-------------------|
| .claude/agents | セッション開始時点でまとめて前提として抱え込む |
| skills/agents | 「そのSkillが呼ばれたあと」「さらにTaskを実行する直前」に読まれる |

### Skillsの「段階的ロード」と agents/*.md の関係

Skillsの段階ロード：

1. **Discovery** - 「Skillのメタデータ」まで
2. **Loading** - 基本的に SKILL.md
3. **Execution** - skills/agents/*.md は「Execution段階で、そのTaskを実行する直前にまるっと読まれる」

つまり、**agents/*.md の中身は"段階的には"ロードされない**。

Taskを起動すると決まった瞬間に、そのTask仕様書の本文はまとめてコンテキストに入る。だからこそ、ここを重くしすぎると一気にトークンを食うし、Skillsの「コンテキスト効率の良さ」を自分で殺すことになる。

### .claude/agents と skills/agents の使い分け

| 配置場所 | 用途 |
|----------|------|
| .claude/agents（Sub Agent） | セッションの最初から最後まで、ずっと居てほしいキャラ。プロジェクト全体を横断するロール。その分、数やサイズを増やしすぎると、最初からコンテキストを圧迫する |
| skills/agents | 特定のSkillの中だけで必要な Task の仕様書。「このTaskを実行するときだけ読み込めばいい情報」を書く場所。Task実行直前に全文読まれるので、なるべく"設計"中心にして重くしすぎない |

### agents/*.md に書くときの設計ポイント

1. 役割・入力・出力・制約を書く
2. 参照する知識はパスを書くに留める（中身は references/ 側に逃がす）
3. 「何を返さないか」も明記する
4. ファイル自体はできるだけ軽くする

**例：本文執筆エージェント**

```markdown
# 本文執筆エージェント

あなたは技術記事作成ワークフローの **Step 4: 本文の作成** を担当する専門エージェントです。

## 責務

アウトラインを元に、**セクションごとにタスクを細分化し、1 つずつ順番に**質の高い本文を執筆する。

- アウトラインを読み込み、各セクションをタスクとして細分化する
- 1 セクションずつ順番に執筆し、完了を確認してから次に進む
- 一度に全セクションを執筆せず、ステップバイステップで進める

| AI 的（避ける）          | 人間らしい（目指す）          |
| ------------------------ | ----------------------------- |
| 箇条書き 3 つで終わり    | 結論 → 理由 → 具体例の流れ    |
| 1 文の段落が連続         | 3-5 文で 1 つの考えをまとめる |
| 「適切に設定する」       | 具体的な設定値を示す          |
| 「様々な〜」             | 具体的に列挙する              |
| 「〜することができます」 | 「〜できる」                  |

## 入力

- **活用情報**: `articles/{slug}/02-resources.md`
- **アウトライン**: `articles/{slug}/03-outline.md`
- **出力先**: `articles/{slug}/04-draft.md`

## 参照リソース

執筆中は以下を参照すること：
- `references/writing-examples.md` - 良い例・悪い例のサンプル

## 注意事項

- **一度に全セクションを執筆してはいけない** - 必ず1セクションずつ順番に執筆する
- **絶対に箇条書き3つだけで終わるセクションを作らない**
```

---

## 第5章 references/ は「知識をぶち込む場所」じゃなくて「外部ストレージ」 {#第5章}

特にありがちなのが：

> 「Taskの仕様書（agents/*.md）の中に、ノウハウもテンプレも全部詰め込む」

これをやると、正直いってほぼ自爆。

本来 references/ が担う役割は：

> **「Taskが必要なときにだけ、取りに行く知識の置き場」**

常にコンテキストに載せておくものではなく、「必要な瞬間にだけ読む教科書」という感覚で扱った方がいい。

### なぜ「知識を外部化」しないと詰むのか

最初にやらかした構成：

- agents/article-writer.md の中に
  - 文体ルール
  - 記事構成テンプレ
  - SEOの基本方針
  - 良い例・悪い例の本文
  を全部書く

結果：この 1 ファイルだけで **8000 トークン超え**。

Taskが「執筆フェーズに入ります」となった瞬間、この 8000 トークンが一括でコンテキストに載る。そこからさらに下書きを何回も書き直すと、Task側のコンテキストは簡単にパンクする。

### references/ を「教科書置き場」として設計する

references/ に置くべきもの：

- 文体ルール・ガイドライン
- テンプレート
- 参考用のサンプル
- そのSkillで頻繁に参照したい長めのドキュメント

**ディレクトリ構成例：**

```
.claude/skills/tech-article-writer/
  SKILL.md
  agents/
    article-writer.md
  references/
    writing-guide.md          # 文体ルール
    structure-templates.md    # 構成テンプレ
    seo-guidelines.md         # SEOの方針
    examples/
      good-article.md         # 良い記事の例
      bad-article.md          # 悪い記事の例
```

**大事なのは、agents 側には中身を書かないこと。書くのは「どのタイミングで、どのファイルを参照すべきか」だけ。**

```markdown
# 執筆 Task 仕様書

## あなたの役割
リサーチ結果をもとに、技術記事の本文を書く。

## 入力
- リサーチ Task から渡された要約
- 想定読者
- 記事の目的

## 作業の前に読むもの
- references/writing-guide.md（文体のルール確認）
- references/structure-templates.md（構成の候補を決めるとき）

## 必要に応じて読むもの
- references/examples/good-article.md（クオリティを確認したいとき）

## 出力
- 完成した記事本文
- 使用した構成パターンのメモ
```

### references/ を設計するときのポイント

1. **1ファイル1トピックにする**
   - 文体ルール / 構成テンプレ / SEO方針 / サンプル記事を全部 1 ファイルに詰め込むと、それを読んだ瞬間に数千トークンが飛ぶ

2. **「いつ読むべきか」を Task 側で指定しておく**
   - 作業前に絶対読むもの
   - 品質チェックのときだけ読むもの
   - 条件付きで読むもの（長文になるときだけ、など）

3. **具体例は別フォルダに逃がす**
   - 良い例・悪い例・ケーススタディはトークンを食う
   - references/examples/ 配下に分離して、「本当に迷ったときだけ開く」扱いに

### なぜ「知識をTask仕様書に書き込むと死ぬ」のか

> Task仕様書は「どう動くか」だけ書き、「何を知っているべきか」は references 側に逃がす

という設計にしておかないと、Taskを増やした瞬間にコンテキストが破綻する。

**agents に知識を全部突っ込むと：**
- Task実行直前に、その 1ファイル分が丸ごと読まれる
- それを Task の数だけ繰り返す
- その上で、実際の会話ログ・下書き・差分・検証結果が積み上がっていく

**分担すると：**
- Taskごとのコンテキストサイズが抑えられる
- 長いワークフローでも安定する
- 知識の再利用性も上がる（複数 Task から同じ references を参照できる）

---

## 第6章 scripts/ を入れた瞬間、Skillsは「考えるだけじゃなく動く」 {#第6章}

Task と references の話までは「コンテキストの設計」の話。ここから一段ギアを変える。

**Scripts を噛ませた瞬間に、Skillsは：**

「うまく考えてくれるアシスタント」から「考えて → 手を動かすとこまでやる自動化装置」に変わる。

### LLMにやらせるとコスパが悪い仕事

LLMと相性が悪いもの：
- 大量のファイルを機械的にいじる処理
- ログやCSVの集計・変換・分析

これをプロンプトだけでやろうとすると：
- 無駄にトークンを食う
- たまにミスる
- 再現性が低い

### scripts/ の役割は「決まった作業を外出しする」こと

Skills における scripts/ は：

> 「LLMにやらせると微妙な定型処理を、コードとして切り出しておく場所」

一度 Python に落として scripts/format_article.py にしておけば、以降は「スクリプトを回して」と指示するだけで済む。

**例：記事Markdownを整形するスクリプト**

```python
#!/usr/bin/env python3
"""
記事Markdownを整形するスクリプト
- 見出しレベルの整理
- 文末の句読点統一
- 連続した空行の圧縮
- 画像パスを相対パスに変換
"""

import re
import sys
from pathlib import Path

def normalize_headings(text: str) -> str:
    lines = text.split("\n")
    result = []
    seen_h1 = False

    for line in lines:
        if line.startswith("# ") and not seen_h1:
            seen_h1 = True
            result.append(line)
        elif line.startswith("# "):
            result.append("#" + line)
        else:
            result.append(line)

    return "\n".join(result)

def normalize_punctuation(text: str) -> str:
    return re.sub(r"[\.．](\n|$)", r"。\1", text)

def compress_blank_lines(text: str) -> str:
    return re.sub(r"\n{3,}", "\n\n", text)

def main(file_path: str) -> None:
    p = Path(file_path)
    content = p.read_text(encoding="utf-8")

    content = normalize_headings(content)
    content = normalize_punctuation(content)
    content = compress_blank_lines(content)

    p.write_text(content, encoding="utf-8")
    print(f"Formatted: {file_path}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: format_article.py <file_path>")
        sys.exit(1)
    main(sys.argv[1])
```

**ポイント：**
- 一回スクリプトを書いてしまえば、動作は毎回同じ
- どれだけ回してもトークン消費はゼロ
- LLM側は「実行してね」と指示するだけ

### SKILL.md から scripts をどう扱うか

SKILL.md に「どこで scripts を挟むか」を書いておく：

```markdown
## Step 4: 記事の整形

執筆 Task が生成したドラフトファイル（`articles/draft.md`）に対して、
以下のスクリプトを実行して整形すること：

```bash
python scripts/format_article.py articles/draft.md
```
```

### LLM × references × scripts の役割分担

| 要素 | 役割 |
|------|------|
| LLM（Task） | 判断する / 文章を書く / 方針を決める |
| references/ | その判断のための知識・ルール・テンプレを置いておく「外部ストレージ」 |
| scripts/ | 機械的・決定的な処理を担当。ファイル操作・整形・変換などを確実にやる |

ここまで来ると、Skills はもう「プロンプトの塊」ではない：

1. SKILL.md でワークフローの流れを定義し
2. agents/*.md で Task ごとの役割を切り分け
3. references/ に知識を逃がし
4. scripts/ に手作業を押しつける

この4つが揃って、ようやく「Task × Context × Automation」をまとめて扱える仕組みとしての Skills になる。

---

## 第7章 公式Best Practicesとの接続を整理する {#第7章}

### Skillsを公式の言葉で整理し直す

Anthropicの説明：

> Skills = instructions（指示）＋ scripts（スクリプト）＋ resources / references（リソース・知識）の束で、Claudeの能力を拡張するもの

対応関係：

| 公式の言い方 | この記事で扱った要素 |
|--------------|---------------------|
| instructions | ワークフロー全体の定義 & Task仕様書 (SKILL.md, agents/) |
| resources / references | ルール・テンプレ・サンプルなどの知識 (references/) |
| resources/scripts | コマンド・自動化処理 (scripts/) |

### 段階的ロードと「どこまでが対象か」

Claude側の動き：

1. まず各Skillの「メタデータ」だけを見る
2. 関係ありそうなSkillが見つかったら、そのSkillの SKILL.md を読む
3. SKILL.md を読んだうえで、「このTaskを実行しよう」と決まったタイミングで、その Task に対応する agents/*.md や、必要な references/ を読む

**段階ロードの主役はあくまで「メタデータ」と「SKILL.md」**

| ファイル | 位置づけ |
|----------|----------|
| SKILL.md | そこそこ長くてもいいが、無駄に巨大にする必要はない。「このSkillはどんなタスクを、どんな流れで処理するのか」が書いてある中枢 |
| skills/agents/*.md | 段階ロードの"候補探索"には使われない。実行直前に、その Task の仕様書として一気に読まれる。だからこそ「仕様だけを書く」「知識は references に逃がす」が効いてくる |

### 公式が強調している「自動で呼ばれる専門家」という考え方

> Skills は「必要になったときに自動で召喚される専門家の束」

| 要素 | 役割 |
|------|------|
| .claude/agents（Sub Agent） | ずっと同席している「このプロジェクト全体のメンバー」 |
| Skills | あるタスクが来たときに、メタデータと SKILL.md を見て「たぶんこのSkillだな」と判断され、中で定義された Task仕様（agents）、知識（references）、スクリプト（scripts）が必要な順番で呼び出される「期間限定のチーム」 |

### Context Engineeringとの接点

Context Engineering側でよく語られていること：

- ちゃんとしたモデルなら、だいたいのことは「コンテキストさえ良ければ」できる
- 逆に、多くのエージェントの失敗は「モデルの性能」ではなく「文脈の設計ミス」

> モデルを賢くしようとする前に、「いつ、何を、どこまで見せるか」を設計する方がリターンが大きい

---

## 第8章 結論：Skillsは「コンテキスト設計のフレームワーク」 {#第8章}

### Skillsを「スラッシュコマンドの強化版」としか見ないと、ほぼ何も始まらない

スラッシュコマンドは、本質的には「メインセッションのコンテキストに、決め打ちのプロンプトを追加する仕組み」。

一方、Skills の構造：

| 要素 | 役割 |
|------|------|
| .claude/agents | セッション全体で"常駐"させたいエージェント定義。メインのコンテキストに、最初から乗っている前提情報 |
| SKILL.md | 特定の種類のタスクに対する「ワークフローの中枢」。どんなフェーズをどの順番で進めるか、という流れの定義 |
| skills/agents/*.md | 各 Task が「どう振る舞うか」の仕様書。Skill 適用後、「その Task を実行する直前にだけ」読まれる設計。だからこそ、役割・入力・出力・制約だけを書き、知識は持たせすぎない |
| references/ | ルール・テンプレ・サンプルなど、「必要なときだけ取りに行く知識」の外部ストレージ。1ファイル1トピックで分解し、「いつ読むか」を Task 側で指定する |
| scripts/ | ファイル操作や整形など、LLMにやらせるとコスパが悪い処理を外出しする場所。「判断はLLM、機械的な作業はコード」に分業するための実行部品 |

> **Skills = Task設計 × コンテキスト設計 × 自動化設計を束ねるフレームワーク**

### 実務でSkillsをちゃんと使うための最低限のステップ

1. **扱いたいタスクをひとつ決めて、それを分解する**
   - 例：技術記事を書く → リサーチ / アウトライン作成 / 本文執筆 / 整形・フォーマット / 最終レビュー
   - 「どこで Task を区切るか」を先に決める

2. **SKILL.md に「ワークフロー全体の流れ」を書く**

3. **各フェーズを Task として切り出し、それぞれに skills/agents/*.md を用意する**
   - 役割 / 入力 / 出力 / 返さないもの をきっちり言語化する

4. **Taskごとに必要な知識・ルール・テンプレを、references/ 側へ逃がす**
   - 1ファイル1トピックで分解
   - 「作業前に絶対読む」「チェックのときだけ読む」を仕様書に明記する

5. **明らかに「LLMにやらせると面倒な処理」は、scripts/ でPythonコードに落とす**

### Skillsは「再利用可能なコンポーネント」として設計されている

スラッシュコマンドは、そのエディタ / その環境 / その1プロジェクトの中で完結しがちな「ローカル便利機能」。

**Skillsは最初から発想が逆：**

- .claude/skills/〜 という、ツール側が標準で見る場所に置かれる
- SKILL.md / agents / references / scripts というディレクトリ構造が固定で、API経由でも読める
- Claude Code だけじゃなく、Cursor・API・将来の別クライアントからも"同じSkill"を叩ける前提で設計されている

一度ちゃんと設計してしまえば、「特定のプロジェクトの中でしか使えないプロンプト」ではなく、**「自分の"思考 + 作業フロー"をパッケージ化したライブラリ」**として扱える。

---

## 第9章 まとめ：Skillsの本当の価値 {#第9章}

> **Skills = 「Task単位でコンテキストを設計し、知識と作業を外部化したうえで、それを再利用可能なコンポーネントとして束ねる仕組み」**

スラッシュコマンドと比較して見える差は、機能の数やUIの違いではなく：

- コンテキストをどう扱うか
- タスクをどう分割するか
- その設計をどこまで再利用可能な形で固定するか

というレイヤーの話。

SKILL.md にちょっと長めのプロンプトを書いて満足しているうちは、Skillsのポテンシャルの半分も触れていない。

Task・agents・references・scripts まで使い切った瞬間から、「スラッシュコマンドと何が違うの？」という問い自体が、だんだん意味を失っていく。

そこまで設計して初めて、Skillsは「単なる便利機能」から**「自分の思考と作業フローをインフラ化するための設計フレームワーク」**に変わる。

---

## 著者について

**そら（福島楓人）**
- 生成AIエンジニア
- 学生・若手向けAIコミュニティ「gakuse.ai」代表
- X（旧Twitter）で「AI×自動化」について発信

---

*この記事は note の有料記事（¥1,500）を含む完全版です。*
